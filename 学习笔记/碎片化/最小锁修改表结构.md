好，我给你把 `pt-online-schema-change` 的关键点和触发器+迁移冲突处理逻辑整理一下，方便你快速理解和复习：

---

## 📌 pt-online-schema-change 总结

### 1. 工具作用

- 用于 **MySQL/MariaDB 大表在线变更结构**（加列、改类型、加索引、改字符集等）。
- 避免直接 `ALTER TABLE` 锁表，业务几乎无感知。

---

### 2. 工作原理

1. **建影子表**：复制原表结构，并加上新修改。
2. **迁移数据**：分批把原表数据复制到影子表。
3. **建触发器**：在原表上建 `AFTER INSERT/UPDATE/DELETE`，保证迁移过程中数据实时同步。
4. **原子切换**：数据迁移完成后，`RENAME TABLE` 替换原表。
5. **清理**：删触发器、旧表。

---

### 3. 触发器逻辑

- **INSERT**：新行同步到影子表。
- **UPDATE**：如果影子表有 → 更新，否则 → 插入。
- **DELETE**：删除影子表的对应行（如果不存在也没关系）。

---

### 4. “触发器先写，迁移后复制” 场景

- 如果某行数据还没迁移，用户执行了 `UPDATE`：

- 触发器会先在影子表 **插入最新版本**。

- 之后迁移线程再扫描原表时遇到这条数据：

- 使用 `INSERT IGNORE` 或 `REPLACE` 插入。
- 如果已存在就跳过或覆盖，最终保证影子表是 **最新数据**。

---

### 5. 核心 SQL 语义

- **INSERT IGNORE**：尝试插入，如果主键冲突 → 忽略。
- **REPLACE**：尝试插入，如果主键冲突 → 先删旧行，再插入新行。
- 这就是为什么不会出现“重复或报错”的关键。

---

### 6. 常用命令示例

```
pt-online-schema-change \
  --alter "ADD COLUMN age INT" \
  D=mydb,t=users \
  --execute
```

参数：

- `--alter`：指定修改内容。
- `D=mydb,t=users`：数据库和表名。
- `--execute`：真正执行（没有的话只检查不运行）。
- `--dry-run`：预演模式。

---

✅ **总结一句话**：  
`pt-online-schema-change` 靠 **影子表 + 触发器 + IGNORE/REPLACE 插入策略**，解决了「数据迁移和实时更新冲突」问题，保证影子表始终和原表一致，最后再无缝切换。

---

要不要我把 **真实 pt-online-schema-change 生成的触发器 SQL** 给你展示一下？这样你能完全看到它是怎么实现的。