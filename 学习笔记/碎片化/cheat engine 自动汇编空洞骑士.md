空洞骑士找血量以及货币

空洞骑士的血量通过被击打，通过变化去扫描到关键几个指向血量的地址，刚开始的血量是5直接通过ce搜索5

![](1757662888654-65cf1805-985d-40ce-8e22-824df82e9777.png)

![](1757662868384-55291226-567a-4ad2-80cd-4f8f5e9330f0.png)

在被小怪击打后血量发生变化，这里被击中两次，直接搜索3

![](1757662934253-6c1a18eb-0f56-4682-8a96-9ce59a99f521.png)

![](1757662960609-0339b2fd-f714-4d96-a46b-d26b5f56525b.png) 血量值变为2，同上操作

![](1757662990089-15e33cbe-7feb-4fa8-bee5-aa6125b9438c.png)

![](1757662995276-2ee04856-cd4c-4292-8e66-ad8aa31e8fbf.png)

搜索1

![](1757663013166-d1c6f1ce-166b-4837-b749-54623d9cb698.png)

生命值归零,搜索5

![](1757663048403-fe2ee6f6-955b-461b-9ad8-4170a6c46d41.png)

![](1757663099979-bfb8ed5a-e865-40e0-a959-83b6c96cbd1c.png)

最后这三条在我们血量变化的同时也跟随变化，我们需要从中找到我们需要的，通过双击将三条添加到ce下面的备忘录栏

![](1757663257596-9ac5ca94-3ff7-4b32-9721-884047d2e6e1.png)

分别修改三个数值为不同的数字，然后点击前面的激活，找小怪攻击我们，通过小怪攻击我们几次死亡，分析到哪一个血量是有效的，

然后寻找是谁修改了这个血量值

![](1757663406119-e609879a-72a6-48b9-a06d-a9fae635a0e5.png)

![](1757663445420-591bacec-937b-4c8e-a742-a4c22459cc1a.png)

在我们不进行操作的时候这个指令一直在读取血量，其中mov rax,[rax+0000021c],rax现在是我们的血量值，那么说明血量就在rax+0000021c这个地址存放，我们只要找到rax里面存放的地址是什么，哪里来的就能准确定位血量值

![](1757663603780-eaaef88d-d5a9-4d77-b8f2-39aac8826ac8.png)

点击进来发现，rax现在的值是5，这是因为rax被赋值为血量值了，我们可以看到ce提示我们指针值可能是21F6BA88000，通过这个地址+0000021c发现就是我们之前找到的有效的血量地址，所以现在我们要追踪的就是21F6BA88000这个地址，通过ce新搜索内存中的这个地址

![](1757663727647-df50de13-cb63-47cf-b58c-c48b8e1f1989.png)

搜索地址，然后查看是谁访问了这个地址，最后我们定位到了mov rax,[rax]这条汇编

![](1757663780542-4d2603cd-aa4b-40df-8228-b47e4ae82e05.png)

我也试着通过血量值变化去查看是谁读写了这个地址，没有找到，其中这个地址谁访问了，只有部分搜索结果能够找到，然后就分析找到的这条附近的汇编代码，发现我们需要的地址是通过对寄存器赋值常量地址，所以我通过网上搜索找到下面这段话，感觉和我现在遇到的问题很匹配，所以变按照他的思路，对寄存器赋值这段进行hook，在这里注入我们的汇编代码，获取赋值给寄存器的常量地址到我们申请的内存中，我们可以在ce中直接访问到我们这快内存中的值，然后通过这个值加上上面21c偏移量成功获取到指向血量的指针。我也试着在第一次搜索修改血量值成功的汇编代码附近获取寄存器中的地址，到我们的内存中，可以生效吗？可以，但是这段代码是公用多，地址多次发生变化不会一直有效，按照他的话说而跟踪到最后的常量地址，则只需要游戏代码已经载入这些模块，不需要变动就能刷新指针。

然后就是ce的自动汇编代码了

  
unity游戏相对来还好，CE只要开启Mono，查到代码改写后，可以不用跟踪代码，直接用地址名定位后注入人造指针(有可能需要排除共用代码的问题）。 而不用Mono执意要跟踪的话，追个几层call后会发现直接对寄存器赋常量（有算法，重载会变动）地址值，从这里aob注入人造指针也行。用Mono在代码改写处注入的好处是方便快捷，但需要游戏中实际指行到了变动最终的数值才能刷新到指针。而跟踪到最后的常量地址，则只需要游戏代码已经载入这些模块，不需要变动就能刷新指针。

如果需要在ce中使用我们的内存地址需要`**registersymbol**`**，**这里我们申请的newPtr也是一个指针，所以我们获取到的地址应该存放到【newPtr】中，也就是指针指向的内存地址中，这里我是开启了mono特性，通过 mono地址来定位汇编代码，这样就能准确hook获取地址

```
[ENABLE]
alloc(newmem,2048,"PlayerData:get_instance"+12)
alloc(newPtr,8)
registersymbol(newPtr)
label(returnhere)
label(originalcode)

newmem:
    mov [newPtr],rax        // 保存rax
originalcode:
    mov rax,[rax]           // 原始指令
    test rax,rax            // 原始指令
    jmp returnhere

"PlayerData:get_instance"+12:
jmp newmem
nop 1                      // 这里数量要和覆盖的字节对齐
returnhere:

[DISABLE]

"PlayerData:get_instance"+12:
db 48 8B 00 48 85 C0       // 恢复原始字节

unregistersymbol(newPtr)
dealloc(newPtr)
dealloc(newmem)

```

最后在ce中添加指针newPtr，在添加一次偏移21c就是我们的血量的地址