## 文件逻辑顺序

```
+-------------------+
| ELF Header         |  <-- 64B (64位) / 52B (32位)
+-------------------+
| Program Header Table (可执行文件才用) |
+-------------------+
| Section 数据 (各种段/节) |
|   .text (.text段)    |
|   .data (.data段)    |
|   .rodata            |
|   .bss (通常文件中不占空间) |
|   .symtab            |
|   .strtab            |
|   ...                |
+-------------------+
| Section Header Table (SHT) |
+-------------------+
```

### 各部分理解

- **Section（节）**：
- `.text, .data, .bss, .rodata, .symtab, .strtab ...`
- 编译器生成，主要用于 **链接、调试、符号信息**
- 在目标文件 `.o` 和可执行文件里都有，但 **可执行文件运行时可能不需要所有 Section**
- **Segment（段）/Program Header Table**：
- 由 **链接器生成**，主要用于 **OS loader 映射内存**
- 一个 Segment 可能包含多个 Section
- 例如：

```
LOAD Segment 1 → .text + .rodata
LOAD Segment 2 → .data + .bss
```

- **Section Header Table**：
- 描述所有 Section 在文件里的偏移、大小、类型
- 链接器、调试器使用
- 可执行文件运行时 loader 通常不需要用
- **符号表 (**`**.symtab**`**) + 字符串表 (**`**.strtab**`**)**：
- 属于 Section 的一部分
- 保存函数/变量符号信息，用于调试和链接
- 不参与运行时加载

### 总结顺序理解

- **ELF Header**：必须最前面
- **Program Header Table（段表）**：可执行文件用来加载段
- **Section 数据（节 + 符号表）**：分布在文件不同偏移
- **Section Header Table（节表）**：文件最后，描述各节在文件的偏移

🔹 注意：文件里不一定严格按“头 → 段表 → 节 → 符号表”的顺序排列

- ELF 文件使用偏移指针（`e_phoff`, `e_shoff`）来告诉你段和节的数据在哪里
- 有些 Section 可以放在文件任意位置

## 大小端

### 个人理解

大端适合人读，小端适合机器读，然后这个存放的话是按照你数据，比如要写入int型，他是4字节，也就是说接下来的四个字节是小端，人读取的时候，应该从第四个字节往前看，然后一个字节8位，2个16进制数，从左往右读，不管是大端还是小端都是， 小端/大端只影响**字节顺序**，**单个字节内部的位顺序是不变的**，依然是高位在左、低位在右。

### ai

### 1. 大端 vs 小端的本质

- **大端（Big Endian）**

- 高位字节放在 **低地址**，低位字节放在 **高地址**。
- 这种存放方式和我们写数的习惯一致：高位在前，所以人读起来直观。

- **小端（Little Endian）**

- 低位字节放在 **低地址**，高位字节放在 **高地址**。
- CPU 处理加减乘除时直接访问低地址开始的字节就能立即计算，所以机器读写更高效。

---

### 2. 内存和字节序

假设我们有一个 `int32_t x = 0x12345678`：

|字节|大端内存|小端内存|
|---|---|---|
|地址0|12|78|
|地址1|34|56|
|地址2|56|34|
|地址3|78|12|

- **每个字节 8 位**，显示成 **两位十六进制**。
- 不管大端还是小端，人阅读时都是 **从左到右**看每个字节的十六进制。

---

### 3. 人读 vs 机器读

- **人读**：通常看 **高位在前的顺序**，所以大端直观。
- **机器读**：CPU 读取 **最低地址开始的字节**，根据架构自行组合成整数 → 小端更方便。

---

### 4. 总结你的理解

1. 数据存放时：

- 小端：低地址是低位字节，高地址是高位字节
- 大端：低地址是高位字节，高地址是低位字节

2. 人读十六进制：

- 从左往右，每个字节 2 个十六进制数
- 对小端，最高有效字节在最后，需要从右往左组合才能看成完整数值
- 对大端，最高有效字节在最前，看起来和数值一致

3. 不管大端还是小端：

- 内存里每个字节都是 **8 位 → 两位十六进制**
- 人读取顺序还是 **左到右**

---

可以这么记一个口诀：

**“大端高位在前，人读舒服；小端低位在前，CPU 读快。”**

---

如果你想，我可以帮你画一张 **4 字节整数的大端 vs 小端内存图**，标注字节地址、二进制和十六进制，这样你一眼就能看懂。

## 案例

我简单写了一个c程序：

```
#include <stdio.h>

// 全局变量
int MAX_VALUE=100;
static int test=10;

int MIN_VALUE;
static int prod;

int main(){
    printf("hello,world!!!");
    return 0;
}
```

本意是想观察编译之后elf文件格式，了解全局变量静态变量存放在elf文件的哪个部分，程序运行之后存放在虚拟内存中。

```
gcc ./hello.c -o a.out
```

a.out就是elf可执行文件，使用readelf读取elf header

```
readelf -h a.out       # 查看 ELF 文件头
readelf -S a.out       # 查看 Section（节表）
readelf -l a.out       # 查看 Program Header（段表，内存映射用）
```

```
readelf -h ./a.out
ELF 头：
  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：              0x401040
  程序头起点：              64 (bytes into file)
  Start of section headers:          15528 (bytes into file)
  标志：             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         32
  Section header string table index: 31
```

![](1757406005810-93794d0d-7212-41c8-b885-c2e0077859cf.png)

elf的elf header 32位占用52字节，64位占用64字节大小，其中前16位字节位魔数，74 45 4c 46 表示这是一个elf文件，前四个字节是固定魔数，然后02是表示64位elf文件，01表示小端序，01表示elf版本

可能会想解析的时候如何处理大小端呢？

直接按字节加载文件，读成字节数组，字节数组[5]就是字节序，之后处理就可以根据该标志去读取字节。

上面使用readelf显示出来的内容是经过readelf处理过的，使用hexdump查看原始字节

```
[wrw@vbox c]$ hexdump ./a.out | head -n 20
0000000 457f 464c 0102 0001 0000 0000 0000 0000
0000010 0002 003e 0001 0000 1040 0040 0000 0000
0000020 0040 0000 0000 0000 3ca8 0000 0000 0000
0000030 0000 0000 0040 0038 000d 0040 0020 001f
0000040 0006 0000 0004 0000 0040 0000 0000 0000
0000050 0040 0040 0000 0000 0040 0040 0000 0000
0000060 02d8 0000 0000 0000 02d8 0000 0000 0000
0000070 0008 0000 0000 0000 0003 0000 0004 0000
0000080 0318 0000 0000 0000 0318 0040 0000 0000
0000090 0318 0040 0000 0000 001c 0000 0000 0000
00000a0 001c 0000 0000 0000 0001 0000 0000 0000
00000b0 0001 0000 0004 0000 0000 0000 0000 0000
00000c0 0000 0040 0000 0000 0000 0040 0000 0000
00000d0 0588 0000 0000 0000 0588 0000 0000 0000
00000e0 1000 0000 0000 0000 0001 0000 0005 0000
00000f0 1000 0000 0000 0000 1000 0040 0000 0000
0000100 1000 0040 0000 0000 014d 0000 0000 0000
0000110 014d 0000 0000 0000 1000 0000 0000 0000
0000120 0001 0000 0004 0000 2000 0000 0000 0000
0000130 2000 0040 0000 0000 2000 0040 0000 0000
```

![](1757407530633-53e28b00-1e00-445f-afc5-52b80cf87ca3.png)

透过hexdump查看我发现有些问题，按照我之前所想，那不是说显示出来应该是46 4c 45 7f 这样才是呢，所以是使用hexdump的姿势有问题，应该按照字节读取顺序去读，

前两个字节是固定顺序的不按照大小端顺序，都是这个顺序，而后续读取其他的结构，根据结构大小，读取指定大小的字节，然后按照字节序去合成整数，而且根据你得平台，小端机器读取出来就是小端存储就是正常的数值。

## 问题

### 多个-c编译出来的文件，是不是也是elf上面这种格式，然后把各个需要链接的文件每个节放到一块，然后重新计算各个节中的偏移

完全正确 😄，你的理解已经很接近实际情况了，我帮你整理得更系统一些：

---

#### 1. 每个 `-c` 编译生成的 `.o` 文件

当你执行：

```
gcc -c foo.c -o foo.o
```

得到的 `foo.o`：

- **也是 ELF 文件**，只是类型是 **Relocatable File** (`ET_REL`)
- 内部结构和可执行文件类似，包含：

- **ELF Header**
- **Section Header Table**
- **各个 Section 数据**（.text, .data, .bss, .rodata, .symtab, .strtab 等）

- **没有 Program Header Table**，因为 `.o` 不能直接运行，OS loader 不需要它

所以可以把每个 `.o` 看成一个小型 ELF 文件，带有完整的 Section 信息。

---

#### 2. 链接器如何合并多个 `.o`

假设有 `foo.o`、`bar.o`，链接成 `a.out`：

1. **读取每个** `.o` **的 Section**

- `.text`、`.data`、`.bss` 等
- `.symtab` 保存符号表
- `.rel.text` 保存重定位信息

2. **重定位和合并**

- 链接器会把同类 Section 合并到一起：

- 所有 `.text` → 新可执行文件的 `.text` 段
- 所有 `.data` → 新可执行文件的 `.data` 段

- 同时 **计算每个 Section 在新文件中的偏移**

- ELF Header + Program Header + 合并后的 Section 数据
- Section Header Table 最后统一记录偏移和大小

3. **生成 Program Header Table（段表）**

- 链接器根据合并后的 Section 创建 Segment
- 比如：

```
LOAD Segment 1 → .text + .rodata
LOAD Segment 2 → .data + .bss
```

4. **修正符号表和重定位信息**

- `.symtab` 中每个符号的地址重新计算
- 所有重定位条目应用到新的地址

5. **写入 ELF Header 和 Section Header Table**

- `e_phoff` → Program Header Table 偏移
- `e_shoff` → Section Header Table 偏移
- Section 偏移和大小全部更新

---

#### 3. 总结

- 每个 `.o` 文件：小型 ELF 文件（带 Section）
- 链接器把 `.o` 的 Section **按类型合并**，重新分配偏移和地址
- 可执行文件最终 ELF：

- ELF Header → 描述整个文件
- Program Header → 描述内存映射
- Section 数据 → 合并后的 .text/.data/.bss/...
- Section Header → 描述每个 Section 在文件中的偏移和大小

- 符号表和重定位信息也更新到新的偏移

---

如果你愿意，我可以帮你画一张 **多个** `.o` **文件如何合并成 ELF 可执行文件的示意图**，把 Section、符号表、偏移、Segment 都标清楚。这样你能更直观地看到整个流程。

### 哪静态链接的话其实就和多链接一个.o文件一样，把各部分给复制进来，哪动态链接库部分的链接呢

对，你理解静态链接的部分完全正确 ✅：

- **静态链接**就是把所有 `.o` 文件以及静态库（`.a` 文件）里面需要的 Section **直接拷贝进最终可执行文件**
- 链接器会重新计算每个 Section 在文件中的偏移、符号地址、重定位信息等

---

动态链接和静态链接不一样，关键点是：

#### 1. 动态链接不是把代码拷贝进可执行文件

- 可执行文件中不会包含 `.so` 的机器码
- 可执行文件会在 **Program Header** 中记录需要加载的动态库名和依赖（通过 `.interp` 段和 `.dynamic` 段）
- 符号解析、地址重定位留到程序运行时由 **动态链接器 (**`ld.so`**)** 完成

---

#### 2. ELF 可执行文件中的关键段

|段/Section|用途|
|---|---|
|`.interp`|指定动态链接器路径（例如 `/lib64/ld-linux-x86-64.so.2`）|
|`.dynamic`|记录需要的动态库、符号表、重定位信息|
|`.dynsym`|动态符号表，供运行时链接使用|
|`.dynstr`|符号名字符串表|
|`.rela/.rel.plt`|PLT 表的重定位条目，供延迟绑定函数使用|
|`.plt`|Procedure Linkage Table，调用动态库函数入口|
|`.got`|Global Offset Table，存储动态符号运行时地址|

---

#### 3. 动态链接流程（简化）

1. 链接器生成 ELF 可执行文件时：

- 不拷贝 `.so` 的机器码
- 生成 `.interp` 指向动态链接器
- 生成 `.dynamic/.dynsym/.dynstr/.rel.plt/.plt/.got` 等段

2. 程序运行时：

1. 内核加载 ELF 可执行文件，读取 `.interp` 找到动态链接器
2. 动态链接器 (`ld.so`) 加载所需的 `.so`
3. 解析符号，完成 **重定位**

- `.got`/`.plt` 更新为真实函数地址

4. 最终程序和动态库的代码一起在内存里运行

---

#### 4. 总结对比

|类型|编译期/链接期|运行期|
|---|---|---|
|**静态链接**|拷贝代码+数据到可执行文件|直接运行，无需动态库|
|**动态链接**|生成 `.dynamic/.plt/.got`，记录依赖|运行时由 `ld.so` 加载 `.so` 并重定位|

🔹 所以动态库部分在 ELF 文件里不是“拷贝进去”，而是留下了 **引用和重定位信息**，运行时才真正加载和绑定。

---

如果你愿意，我可以画一张 **静态链接 vs 动态链接 ELF 文件结构对比图**，标出 `.text/.data/.plt/.got/.dynsym` 等段的区别，会更直观。

### elf文件其实大概就三部分elf头，段表，节表，然后程序执行的时候执行段表把节表各部分加载到虚拟内存各部分

你的理解大体上是对的，但可以再稍微梳理得更准确一些：

1. **ELF 文件的基本结构**

- **ELF 头（ELF Header）**：整个文件的入口，描述了文件类型（可执行、可重定位、共享库）、架构、字节序、入口点地址、程序头表偏移、节头表偏移等。
- **程序头表（Program Header Table, PHT）**：主要用于 **运行时加载**。它描述了哪些部分需要被映射到内存、映射的虚拟地址、大小、权限等。
- **节头表（Section Header Table, SHT）**：主要用于 **静态链接和调试**，描述文件的各个节（`.text`、`.data`、`.bss`、`.rodata`、符号表等）在文件中的偏移和大小。

2. **文件和内存映射关系**

- 编译器生成的目标文件（.o）和静态库文件中，节表是最重要的，因为它们用于链接器合并各个对象文件。
- 可执行文件（ELF 可执行文件，ET_EXEC 或 ET_DYN）在加载时，操作系统 **不会直接按照节表加载**，而是根据 **程序头表** 来映射段（Segment）到内存。
- 一个段可以包含多个节（Section）。例如，`.text`、`.rodata` 通常会被合并到一个可执行段中；`.data`、`.bss` 合并到一个可写段。

3. **总结**

- **节表（Sections）** → 链接器使用（合并、重定位、符号表等）
- **程序头表（Segments）** → 加载器使用（映射到虚拟内存，设置权限）

所以你说的“程序执行的时候执行段表把节表各部分加载到虚拟内存各部分”可以更精确地说成：**程序执行时，加载器根据段表映射段到虚拟内存，而段中可能包含多个节。节本身在运行时不直接被操作系统使用**。

如果你想，我可以画一张 **ELF 文件结构与内存映射关系图**，让这个概念更直观。你想让我画吗？

### 这个说的是动态连接器吗，程序运行过程中的

对的，你理解得很精准。这里要区分两个阶段的“连接/加载”概念：

1. **编译/静态链接阶段（Linker，ld）**

- 链接器在编译结束后把多个目标文件（.o）和库文件（静态库 .a）合并成一个可执行文件（或共享库 .so）。
- 在这个阶段，**节表（Section）**非常重要，因为链接器需要知道每个节的位置、大小以及符号信息来做 **重定位、合并节、生成符号表**。
- 结果是生成的 ELF 文件，包含 **ELF 头、程序头表、节表、符号表等**。

2. **运行/加载阶段（Loader & Dynamic Linker/Loader）**

- 当你运行程序时，内核加载器（loader）根据 ELF 的 **程序头表（Program Header Table, PHT）** 把各个段（Segment）映射到虚拟内存。
- **动态连接器（Dynamic Linker，ld.so）**则负责解析共享库依赖、符号重定位、初始化构造函数等。
- 在这个阶段，**节表基本上不被使用**，操作系统只关心段（Segment）的地址、权限和大小。

所以你之前说的“程序执行的时候执行段表把节表各部分加载到虚拟内存”实际上对应的是 **运行阶段，loader/动态连接器** 在工作，但严格来说加载器并不直接按照节表加载，它是按照 **段表映射段**，段内部可能包含多个节。

如果你愿意，我可以帮你画一张 **静态链接 vs 动态加载 ELF 结构和内存映射的流程图**，看一眼就很清楚这两个阶段的区别。你想要这张图吗？