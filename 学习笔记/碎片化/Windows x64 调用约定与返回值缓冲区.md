好的 ✅ 我帮你把刚才关于 **fastcall、参数传递、返回值缓冲区** 的知识整理成一个知识库条目，方便你以后查阅。

---

## 1. Windows x64 调用约定

在 Windows x64 平台上，微软规定的调用约定是统一的（常称为 **fastcall**，但和 32 位时代的 fastcall 不完全一样）：

- **RCX** → 第 1 个参数
- **RDX** → 第 2 个参数
- **R8** → 第 3 个参数
- **R9** → 第 4 个参数
- **其余参数**：压入栈上传递（右到左顺序）。

**返回值规则：**

- 如果返回值是整数或指针，并且 ≤ 64 bit，返回值放在 **RAX**。
- 如果返回值是浮点数，使用 **XMM0**。
- 如果返回值是较大的结构体（struct/class），调用方需要准备一个 **返回值缓冲区**，并把缓冲区地址作为 **隐藏参数（第 0 个参数）传给函数**。

---

## 2. 隐藏的“第 0 个参数”

当函数需要返回一个较大的对象时：

- 调用方先分配一块内存作为返回值缓冲区。
- 将缓冲区地址放入 **RCX**（相当于第 0 个参数）。
- 之后，**原本的第 1 个参数** 就会放在 **RDX**，第 2 个参数放在 **R8**，以此类推。

📌 这就是为什么你在 IDA 里看到：

- 反编译函数签名显示只有 1 个参数，但汇编里却有 **RCX 和 RDX 都在用**。
- 其中 **RCX 实际上传的是返回值缓冲区地址**，真正的逻辑参数从 **RDX** 开始。

---

## 3. 示例说明

假设函数声明为：

```
MyStruct GenerateKey(int keyLen);
```

编译器可能会翻译为：

```
void GenerateKey(MyStruct* ret_buffer, int keyLen);
```

调用时：

```
; 调用前调用者分配缓冲区地址到 rcx
lea rcx, [rsp+buffer]   ; 返回值缓冲区地址（第0参数）
mov edx, 10             ; keyLen = 10 （第1参数）
call GenerateKey
```

函数内部写入 `ret_buffer`，最后返回时 `RAX` 里通常也会放 `ret_buffer` 的地址，供链式调用。

---

## 4. 关键点总结

1. **Windows x64 调用约定固定**：前 4 个参数走寄存器 RCX, RDX, R8, R9。
2. **返回值 ≤64bit → RAX**；浮点数用 XMM0。
3. **大结构返回值 → 隐藏缓冲区地址作为第 0 参数传递**。
4. **IDA 反编译可能省略了隐藏参数**，所以汇编看起来“参数比声明多”。
5. 调试/逆向时，要注意区分 **真实参数** 和 **隐藏返回值缓冲区**。

---

要不要我帮你把这个整理成 **对照表（寄存器 → 参数位置 / 返回值规则）**，方便你调试时直接查？