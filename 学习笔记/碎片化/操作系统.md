# 内存

## 概念

计算机的**物理内存**由操作系统统一管理，被抽象为**虚拟内存系统**。每个用户程序启动后，操作系统会为它分配一整块独立的虚拟地址空间，这块空间就像是一个虚拟的“进程小世界”，里面包含 `.text`（代码）、`.data/.bss`（全局变量）、堆、栈等结构。程序在这块虚拟空间中运行，彼此之间互不干扰，而这所有的虚拟地址最终通过页表映射到物理内存。

## 通过frida hook 程序去理解内存

在hook中我们在应用程序中打印出来函数的地址，我们不能直接hook这个地址，因为这个地址是在这个应用程序的虚拟地址，直接hook这个地址，会不知道访问的是什么哪里

Frida 等 hook 工具之所以能访问另一个进程的虚拟地址，是因为它已经“附加”或“注入”到了那个目标进程内部，代码实际上运行在目标进程的虚拟空间中。

- 仅靠地址打印，未附加进程时，是不可能直接 attach 成功的。
- 脚本必须运行在已附加目标进程的上下文。
- 地址要加上程序基址，偏移才能变成真实地址。
- 函数地址要是**真实虚拟地址**，才能直接用 `Interceptor.attach`。

```
import frida
import sys

session = frida.attach("hello")
script = session.create_script("""
Interceptor.attach(ptr("%s"), {
    onEnter(args) {
        send(args[0].toInt32());
    }
});
""" % int(sys.argv[1], 16))
def on_message(message, data):
    print(message)
script.on('message', on_message)
script.load()
sys.stdin.read()
```

```
// todo 注入应用程序
Interceptor.attach(addr, {
    onEnter(args) {
      readStdString(args)
    },
    onLeave(retval) {
        // todo
    }
});
```

### 📌 总结

|   |   |
|---|---|
|疑问|解答|
|所以其实如果我不注入这个程序，通过他打印的地址，通过其他方式创建的指向这个地址的指针也是没用的了|如果你不注入目标程序进程，仅凭它**打印出的虚拟地址**，你在**自己进程中创建一个同样的指针去访问它，是没有任何意义的**，甚至可能导致段错误（Segmentation Fault）。 因为虚拟地址是每个进程**私有的、独立的**，同样的地址在你程序里未必映射到任何有效的物理内存。|
|hook 是跨进程操作吗？|是，但实际通过代码注入实现“变成你进程的一部分”|
|为什么能直接访问虚拟地址？|因为代码运行在目标进程内部，所以地址有效|
|是否违反虚拟地址隔离？|没有，只是“附身到另一个地址空间”中执行而已|
|我能不能直接在自己进程访问另一个进程的地址？|❌ 不行，除非 attach 或借助内核接口|

---

如果你想更深入理解：我可以用 Linux 的 `/proc/PID/mem`、`ptrace`、或者 Windows 的 `ReadProcessMemory` 来讲跨进程内存访问与 hook 的差别——也可以配图解释 Frida 注入与 syscall 层的关系。

  

## 🧠 一图理解：从物理内存到用户程序的地址空间

```
css


复制编辑
物理内存（实际硬件 RAM）
   ↑
[操作系统（内核）进行内存管理]
   ↑
虚拟内存（每个进程独享一份虚拟地址空间）
   ↑
应用程序（如 Rust/C++ 程序运行时的内存）
```

### 📦 各层级解释

### ✅ 1. **物理内存**

- 就是你电脑的实际硬件 RAM，比如 16GB。
- 所有程序共享使用，但 **不能直接操作物理内存**。

---

### ✅ 2. **虚拟内存（操作系统分配的抽象地址空间）**

- 操作系统给每个进程分配一个独立的“虚拟地址空间”。
- 在 64 位系统下，这个空间可能高达 256TB。
- 虚拟地址通过页表映射到真实的物理内存，**不同进程之间完全隔离**。

📌 所以即使两个程序都访问地址 `0x7fff12340000`，也不会冲突 —— 因为背后物理地址可能完全不同。

### 现代 64 位操作系统虚拟地址空间大致划分是：

- **低地址虚拟地址**：分配给用户空间（User Space），这是普通应用程序可用的地址区域。
- **高地址虚拟地址**：分配给内核空间（Kernel Space），内核代码和数据所在的虚拟地址范围。

---

举个例子（以 Linux x86_64 为例）：

|   |   |
|---|---|
|地址范围|用途|
|0x0000000000000000 ~ 0x00007FFFFFFFFFFF|用户空间（程序代码、数据、堆栈等）|
|0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF|内核空间（内核代码、数据、设备映射）|

## 3. “共享”内核空间不矛盾于进程独立虚拟地址空间

- 虚拟地址空间**每个进程独立管理自己的页表**，页表中映射了“用户空间”和“内核空间”。
- **用户空间页表项是进程私有的**，不同进程的用户空间虚拟地址映射到不同的物理页。
- **内核空间页表项对所有进程都是相同的**，指向同一块内核物理内存。
- 这样设计的好处：

- 进程之间**用户空间完全隔离**，互不干扰。
- 内核代码和数据只需在物理内存中存一份，所有进程共享，节省内存。
- 进程运行时只要切换页表即可切换用户空间，而内核空间映射保持不变。

好的，我给你画一张简洁明了的多进程虚拟地址空间示意图，展示用户空间和内核空间的分布与映射关系：

---

```
+---------------------------------------------------------------+
|                       64位虚拟地址空间                        |
+---------------------------------------------------------------+
|                      内核空间（Kernel Space）                 |
| +---------------------------------------------------------+  |
| |               内核代码和数据映射（所有进程共享）           |  |
| +---------------------------------------------------------+  |
|                                                               |
|                                                               |
|                      用户空间（User Space）                   |
| +-----------------+        +-----------------+                |
| |   进程A用户空间  |        |   进程B用户空间  |                |
| | (独立映射到物理内存) |        | (独立映射到物理内存) |                |
| +-----------------+        +-----------------+                |
+---------------------------------------------------------------+
```

---

### 说明：

- **低地址段（用户空间）**：每个进程独立，互不干扰，各自映射到不同的物理内存。
- **高地址段（内核空间）**：所有进程共享，映射到同一块内核物理内存，保证内核代码和数据只有一份。

这就是现代操作系统设计里“虚拟地址空间”管理的核心策略，既保证了进程间的隔离安全，也提高了内核内存利用效率。

- **内核空间**：虚拟地址的高位部分（如64位系统的高地址），所有进程共享，映射到同一块内核物理内存。
- **用户空间**：虚拟地址的低位部分，每个进程独立拥有，映射到不同的物理内存，互相隔离。
- **CPU MMU + 操作系统页表**：负责根据当前运行进程，动态把虚拟地址转换成物理地址。

### 🧱 1. 每个进程都有自己独立的虚拟地址空间

- 操作系统在运行每个程序时，都会为它创建一份虚拟地址空间（VMA）
- 这个空间可能从 `0x00000000` 到 `0x7FFFFFFFFFFF`，但**是每个进程私有的**
- 所以 **虚拟地址“长得一样”，意义却完全不同**

🧠 举例：

|   |   |
|---|---|
|进程 A|进程 B|
|`0x7fffabcd1234`<br><br>指向变量 A 的堆|`0x7fffabcd1234`<br><br>指向变量 B 的堆|

它们地址一样，但在操作系统的页表中，映射到的物理地址是不一样的。

### ✅ 3. **应用程序的虚拟内存结构（逻辑分段）**

当你运行一个 Rust/C/C++ 程序时，操作系统会为其创建如下虚拟空间结构：

```
rust


复制编辑
┌──────────────────────────────┐ 高地址
│   栈（Stack）                 │ 函数局部变量，向下增长
├──────────────────────────────┤
│   mmap区域（共享库、匿名内存）│ 通常用 mmap 分配的大块内存
├──────────────────────────────┤
│   堆（Heap）                  │ 动态分配，如 Box、Vec、malloc，向上增长
├──────────────────────────────┤
│   .bss（未初始化的全局变量）  │ 如：static mut X: i32;
├──────────────────────────────┤
│   .data（已初始化全局变量）   │ 如：static X: i32 = 123;
├──────────────────────────────┤
│   .rodata（只读数据）         │ const 字符串、数字表
├──────────────────────────────┤
│   .text（程序指令代码）       │ 函数、main 代码所在区域
└──────────────────────────────┘ 低地址
```

每个段都有不同的访问权限，比如 `.text` 是可执行但不可写。

## 🔐 这是操作系统提供的内存保护机制：

|   |   |
|---|---|
|特性|描述|
|地址空间隔离|每个进程都有独立的虚拟地址空间|
|虚拟地址映射|同样的虚拟地址，映射到不同的物理内存|
|不能随意访问他人地址|访问未映射或非法权限的地址，操作系统会触发异常（SIGSEGV）|

---

## ✅ 那如果想访问目标进程的这块地址，该怎么做？

你必须走以下几种 **“跨进程访问” 的手段**：

### 1. 🔧 Windows 上：

- `OpenProcess`
- `ReadProcessMemory`
- `WriteProcessMemory`

```
cpp


复制编辑
HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, target_pid);
ReadProcessMemory(hProcess, (LPCVOID)0x7ffe2d8c1000, buffer, size, NULL);
```

---

### 2. 🧵 Linux / macOS 上：

- `ptrace(PTRACE_ATTACH, pid, ...)`
- 读 `/proc/PID/mem`
- 使用 Frida/ GDB / LLDB / gcore 注入脚本

---

### 3. 🕵️ 或者使用 Frida/Inject 技术：

Frida 本质上就是让你的 JS 脚本运行在目标进程内：

```
js


复制编辑
Interceptor.attach(ptr("0x7ffe2d8c1000"), {
  onEnter(args) {
    // 这个地址在目标进程中是有效的
    console.log("Hooked!");
  }
});
```

---

## 🧾 总结

|   |   |   |
|---|---|---|
|场景|能否使用目标打印的地址|说明|
|自己进程中使用目标程序的地址|❌ 无效，因地址空间隔离||
|通过注入/Frida/GDB 附加目标进程|✅ 有效，代码运行在目标地址空间中||
|使用 OS 接口读取目标进程内存|✅ 有效，需获取权限和正确接口||

---

你现在已经具备“操作系统内存空间 + 跨进程访问 + 地址隔离”的完整认知了，非常扎实！  
需要我帮你总结成图解 / 讲解 Windows/Linux 下手动跨进程读取这类地址的例子吗？

是的，但**我们要说得更准确一点**：

✅ **程序注入确实是“在合法权限下”绕过了操作系统提供的内存隔离机制，进入了目标进程的地址空间，从而实现访问和操作它的内存。**

但这个“绕过”不是非法的“漏洞攻击”，而是**操作系统明确提供的调试、控制接口或系统调用的合法用途**。

---

## 🧠 分析：操作系统提供的“内存保护”机制是怎样的？

- 每个进程有独立的虚拟地址空间（防止非法访问）
- 一个进程无法直接访问另一个进程的内存
- 系统调用或内核机制（如 `ptrace`、`VirtualAllocEx`）可以**以管理员或调试者身份访问其他进程内存**

---

## ✅ 所以程序注入是“合法地”绕开的方式

|   |   |   |
|---|---|---|
|技术|是否绕过内存保护？|原理说明|
|✅ Frida|是（合法方式）|注入后代码就在目标进程里运行了|
|✅ GDB/LLDB 调试器|是（合法方式）|使用 `ptrace`<br><br>或 Windows 调试 API|
|✅ Windows API|是（合法方式）|`OpenProcess + WriteProcessMemory`<br><br>等|
|✅ 动态库注入|是（合法方式）|利用加载器加载 `.dll`<br><br>/`.so`<br><br>到目标进程|
|❌ 普通用户程序|否|无法访问别的虚拟地址空间，访问报错|

---

## 🛡️ 为什么系统允许这种“合法绕过”？

这些是为以下场景设计的：

- 调试器：你需要能读取调试目标进程的状态
- 插件系统：动态库注入的本质
- 安全工具 / 监控工具
- 像 Frida 这样的逆向分析工具

但这些接口受限于权限：

- 普通用户无法随意操作其他进程
- 注入另一个进程通常需要 **管理员权限** 或 **进程拥有者相同**
- 现代系统开启了 **代码签名验证** / **防注入** / **SELinux** / **Windows Defender** 等防护机制

---

## 🚨 所以准确地说：

注入确实“绕开”了内存隔离的直接限制，但**本质上是获得授权后的行为，是通过系统提供的接口实现的**，并不是安全漏洞，也不违反设计原则。

---

## 🔐 举个更形象的比喻

- 每个进程是一个独立房间，平常你进不去别人的房间
- 系统管理员（root / SYSTEM）给了你钥匙
- 你用钥匙打开门，进了别人房间放了钩子 → 这是注入
- 操作系统允许你这么做，但前提是你有权限

## 拓展知识

### 📚 如果你还想更深入理解这些内容，我推荐几个关键词去扩展：

|   |   |
|---|---|
|关键词|简要说明|
|「多个进程可以拥有相同虚拟地址，但对应不同物理地址」的原理|- **进程 A 和进程 B** 都在自己的虚拟地址空间中使用了地址 `0x7fff_0000_0000`。<br>- 但它们的页表将这个虚拟地址映射到了 **不同的物理页**（P1 vs P2）。<br>- 所以即使地址一样，内容和数据完全独立！<br>- 操作系统为每个进程维护的虚拟地址 → 物理地址映射|
|虚拟地址与物理地址|页表、TLB、地址映射机制|
|ELF 可执行文件格式|`.text/.data/.bss`<br><br>是如何定义的|
|内存对齐与页大小|通常页为 4KB，对齐有利于性能和保护|
|ASLR|地址空间随机化，增加安全性|
|mmap|虚拟内存分配接口，Linux/Unix 通用|

## 2. 操作系统如何“指定”虚拟地址空间？

### （1）虚拟地址空间的整体划分是固定的

操作系统在设计时会划分虚拟地址空间的不同区域用于不同用途，比如：

- 低地址区域一般给用户空间程序使用
- 高地址区域给内核空间使用（所有进程共享内核空间映射）

例如（64位Linux）：

|   |   |
|---|---|
|地址区间|用途|
|0x0000000000000000 ~ 0x00007fffffffffff|用户空间（程序代码、数据、堆栈）|
|0xffff800000000000 ~ 0xffffffffffffffff|内核空间（内核代码、数据）|

---

### （2）具体映射虚拟地址由操作系统内核通过“内存管理单元”（MMU）和“页表”完成

- 操作系统不会一次性为进程虚拟地址空间全部分配物理内存，而是按需“映射”。
- 进程启动时，内核会将程序的代码段、数据段、堆、栈等映射到**预先规划好的虚拟地址区域**。
- 这些映射是基于程序的可执行文件结构（ELF、PE、Mach-O格式）加载时解析确定的，操作系统的加载器会：

- 读取文件头，确定各段大小、起始地址（虚拟地址偏移）
- 按照这些虚拟地址偏移和基址映射到进程虚拟地址空间

---

### （3）基地址（Image Base）是加载器分配的“起点虚拟地址”

- 加载器为每个模块（程序exe或动态库dll/so）选择一个基地址。
- 程序内部所有代码、数据的地址是基地址+偏移。
- 现代系统有 **ASLR（地址空间布局随机化）**，加载器会随机选择基地址来增加安全性。

---

### （4）内存分配给堆和栈是动态的

- 堆区：由进程申请（malloc/new）时由操作系统通过系统调用（brk/mmap等）动态映射虚拟内存。
- 栈区：由操作系统预先划分固定大小的虚拟内存区域，进程运行时使用。

---

## 3. 简化示意流程

```
plaintext


复制编辑
1. 进程启动：
   -> 操作系统加载器解析程序文件头（ELF/PE/Mach-O）
   -> 读取段信息和基地址
   -> 将代码段、数据段映射到虚拟地址空间指定位置

2. 运行时：
   -> 堆和栈动态映射虚拟内存
   -> 页表记录虚拟地址到物理地址映射
   -> MMU负责虚拟地址转换物理地址

3. 程序执行：
   -> 程序访问虚拟地址空间
   -> CPU通过页表将虚拟地址转为物理地址访问内存
```

---

## 4. 总结

|   |   |
|---|---|
|关键点|说明|
|虚拟地址空间规划|操作系统设计好的用户空间和内核空间地址区间|
|基地址（Image Base）|加载器分配给程序模块的虚拟地址起始点|
|页表|记录虚拟地址到物理地址映射，由内核维护|
|动态内存分配（堆/栈）|按需动态映射，内核通过系统调用管理|
|ASLR|随机化基地址，增强安全，防止固定地址攻击|