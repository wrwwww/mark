# 问题

## wireshark无法捕获浏览器中的https请求

HTTPS全称为Hyper Text Transfer Protocol over Secure Socket Layer或者Hypertext Transfer Protocol Secure，被译为超文本传输安全协议。HTTPS是以安全为目标的HTTP通道，即HTTP下加入SSL层。HTTPS的安全集成是SSL。其中，HTTP协议时通过明文形式传输数据的。目前，大部分网站为了安全，都是要HTTPS协议。

如果网站服务器使用的是HTTPS协议的话，则使用Wireshark捕获到的包都是加密的包。如果响应分析传输的内容，则需要进行解密。其中，解密后的内容为HTTP和HTTP2协议。

如果没有解密，则所有的数据包都是TLS协议。Wireshark中支持通过导入服务器证书和日志文件两种方式来解密HTTPS数据。

  

### 方法一 配置服务器证书

### 方法二 配置环境变量

对于普通用户来说，如果要拿到服务器证书，显然不是一件很容易的事。此时，使用日志文件的方式相对来说就比较简单了。Chrome、Firefox、Edege浏览器都支持使用日记文件的方式记录用来加密TLS数据包对称会话的密钥，然后再Wireshark中指定该日记文件，就可以快速地解密HTTPS数据了。

日记文件方式主要是通过在系统中配置一个环境变量SSLKEYLOGFILE来实现的。

当用户配置SSLKEYLOGFILE环境变量后，就表示告诉浏览器想知道其每次HTTPS会话的key记录。这样，浏览器将会在每次HTTPS会话结束后，将会话数据解密的key记录到keylog文件中，然后Wireshark通过访问keylog文件，使用里面的key就可以解密字节捕获到浏览器中产生的HTTPS会话数据流。

1. 新建系统变量`**SSLKEYLOGFILE**`值为任意位置新建的txt

![](学习笔记/Attachments/1736823463720-a69f6955-2ec8-4910-9bfc-c3fcad5e2567.png)

2. 在Wireshark中设置日志文件，打开首选项

![](学习笔记/Attachments/1736823711466-36c5af3b-137f-450c-b1f8-45b6b692e61e.png)

打开后打开协议

![](学习笔记/Attachments/1736823789647-d25d106c-5fd2-474c-bb12-142a3841c665.png)

选择tls协议

![](学习笔记/Attachments/1736823827415-2fc2d76f-9ae2-470d-b8c8-71db83cbd440.png)

设置文件地址为上面配置的环境变量的文件

![](学习笔记/Attachments/1736823873524-1f4b882c-8ee4-45cb-825b-2919251dc1f7.png)

## app有代理检测

常规抓包工具的使用想必各位都已经非常熟悉，但经常会在实际工作中遇到抓不到数据的情况，比如使用fiddler无法抓到TCP协议的数据，或是遇到app有代理检测，能抓到的数据更是少之又少。今天我们展示下遇到app有代理检测时，我们可以使用什么方法来搞定。

这里以雷电模拟器演示

  

  

## 一次http请求帧分析

使用curl发起一次http请求，并使用wireshark捕获这一过程

```
curl -v http://httpbin.org/json
```

命令行的输出是在事后重新复制的，所以可能会导致与下面分析过程中的ack和seq值有所不同

```
root@localhost:~# curl -v http://httpbin.org/json
* Host httpbin.org:80 was resolved.
* IPv6: (none)
* IPv4: 35.170.145.70, 3.95.50.61, 54.85.23.59, 34.236.82.201, 3.211.176.227, 52.206.88.9
*   Trying 35.170.145.70:80...
* Connected to httpbin.org (35.170.145.70) port 80
> GET /json HTTP/1.1
> Host: httpbin.org
> User-Agent: curl/8.9.1
> Accept: */*
> 
* Request completely sent off
< HTTP/1.1 200 OK
< Date: Fri, 07 Nov 2025 14:04:22 GMT
< Content-Type: application/json
< Content-Length: 429
< Connection: keep-alive
< Server: gunicorn/19.9.0
< Access-Control-Allow-Origin: *
< Access-Control-Allow-Credentials: true
< 
{
  "slideshow": {
    "author": "Yours Truly", 
    "date": "date of publication", 
    "slides": [
      {
        "title": "Wake up to WonderWidgets!", 
        "type": "all"
      }, 
      {
        "items": [
          "Why <em>WonderWidgets</em> are great", 
          "Who <em>buys</em> WonderWidgets"
        ], 
        "title": "Overview", 
        "type": "all"
      }
    ], 
    "title": "Sample Slide Show"
  }
}
* Connection #0 to host httpbin.org left intact
```

![](1762522095352-ab50c07e-407c-4cdd-bd60-5580a079317e.png "wireshark捕获的内容")

好 — 我把你抓包截图里每一帧逐条拆解、说明它在 TCP+HTTP 流程里的角色（谁发的、为什么发、包里重要字段意味着什么、和后续步骤的关系）。为方便阅读，我按抓包里的帧号（图片左侧）来讲。

约定：`192.168.148.128` = 你的客户端（VM）IP；`98.87.231.18` = 远端服务器 IP（httpbin.org 的某个返回 IP）。端口方向写作 `源 -> 目的`。

---

### 帧 107 — `192.168.148.128 → 98.87.231.18`

**类型：TCP SYN**（建立连接的第 1 步）  
**含义：** 客户端发起与服务器的 TCP 连接请求。**关键字段解释：**

- `SYN` 标志：请求建立连接。
- `Seq=0`：首次序列号（初始序列）。
- `MSS=1460`、`SACK_PERM`、`TSval/TSecr` 等：TCP 选项，用来协商最大分片、选择性确认、时间戳等。**作用：** 告知服务器“我要和你建立连接，请回复 SYN+ACK”。

---

### 帧 111 — `98.87.231.18 → 192.168.148.128`

**类型：TCP SYN, ACK**（建立连接的第 2 步）  
**含义：** 服务器应答客户端的 SYN，表示同意建立连接并带上自己的初始序列号。**关键字段：**

- `SYN, ACK`：表示“收到你的 SYN（ack=...），同时我也发起一个 SYN”。
- `Seq=0 Ack=1`：服务器的初始序列号为 0，确认号 ack=1 表示它确认收到了客户端的 `Seq=0`（TCP 的 ACK 会是客户 Seq + 1）。  
    **作用：** 服务器同意建立连接并告知客户端它自己的序列号。

---

### 帧 112 — `192.168.148.128 → 98.87.231.18`

**类型：TCP ACK**（建立连接的第 3 步）  
**含义：** 客户端确认收到了服务器的 SYN+ACK，三次握手完成，连接建立。**关键字段：**

- `ACK`：`Seq=1 Ack=1`（表示客户端的下一个发送序号为 1，确认服务器的 Seq+1）。  
    **作用：** 完成三次握手，TCP 连接进入 ESTABLISHED 状态。

---

### 帧 113 — `192.168.148.128 → 98.87.231.18`

**类型：HTTP (over TCP)** — `GET /json HTTP/1.1`（带有 HTTP 请求的 TCP 段）  
**含义：** 客户端在已建立的 TCP 连接上发送 HTTP GET 请求，目标是 `/json`。  
**关键字段：**

- 这是一个包含应用层数据的 TCP 包（Len>0），通常带 `PSH`（由抓包工具可能没有显示 PSH，但这是请求数据）。
- 包含 HTTP headers（`Host`, `User-Agent` 等）和空行，结束后服务器即可响应。**作用：** 发起 HTTP 请求，等待服务器回复 JSON。

---

### 帧 114 — `98.87.231.18 → 192.168.148.128`

**类型：TCP ACK（对 GET 请求的确认）**  
**含义：** 服务器对客户端刚发出的 GET 请求做出 TCP 层的确认（ACK），表示已收到该请求的字节。**关键字段：**

- `ACK` 表示确认号已向前推进（Ack=...）。**作用：** TCP 层的可靠传输机制：确认收到请求数据，服务器随后发送 HTTP 响应数据（下一个包）。

---

### 帧 119 — `98.87.231.18 → 192.168.148.128`

**类型：HTTP Response (HTTP/1.1 503 Service Temporarily Unavailable)**  
**含义：** 服务器返回 HTTP 503（暂时不可用），并携带响应体（抓包里显示 `text/html`，Len 大小约 391）。  
**关键字段：**

- `HTTP/1.1 503 Service Temporarily Unavailable`：应用层状态码，表示服务端当前不能处理请求（可能是服务器维护、上游服务不可用或限流等）。
- 这个响应可能占用了一个或多个 TCP 包（取决于响应大小与 MSS）。抓包中这行表示 HTTP 报文的起始段或整段（取决于 Len）。  
    **作用：** 应用层直接告知客户端请求未被成功处理（不是 TCP 错误，而是 HTTP 状态）。

---

### 帧 120 — `192.168.148.128 → 98.87.231.18`

**类型：TCP ACK（确认服务器的响应段）**  
**含义：** 客户端确认已经收到服务器发送的 HTTP 响应（或响应的某一段）。**作用：** TCP 的确认机制，保证数据可靠交付。

---

### 帧 123 — `192.168.148.128 → 98.87.231.18`

**类型：TCP FIN, ACK（客户端发起连接关闭的一部分）**  
**含义：** 客户端发起主动关闭连接（发送 FIN 表示“我这边没有数据要发了”），并带有 ACK 确认号。**关键字段：**

- `FIN, ACK`：开始 TCP 四次挥手的第一步（主动关闭的一方发送 FIN）。
- `Seq=79 Ack=338`（示例）：Seq 表示客户端在该连接上已发送的数据的下一个序列号；Ack 表示确认服务器已发送的数据序号。  
    **作用：** 客户端告诉服务器：我这边要关闭写入通道（没更多数据要发），可以开始关闭流程。

---

### 帧 125 — `98.87.231.18 → 192.168.148.128`

**类型：TCP ACK（对客户端的 FIN 的确认）**  
**含义：** 服务器确认收到了客户端的 FIN（即确认客户端不再发送数据）。**作用：** 四次挥手的第二步：服务器确认客户端的关闭请求。

---

### 帧 129 — `98.87.231.18 → 192.168.148.128`

**类型：TCP FIN, PSH, ACK（服务器也发起关闭，并可能带最后的数据）**  
**含义：** 服务器一面确认客户端 FIN，也在自己这边发送 FIN 表示服务器也没有更多数据要发了；`PSH` 表示有推送的数据（如果有剩余未发送的响应数据或告知信息）。**关键字段：**

- `FIN, PSH, ACK`：服务器既确认客户端，又发起自己的关闭，并可能附带最后的数据段。  
    **作用：** 四次挥手的第三步：服务器发出自己的 FIN，准备关闭连接。

---

### 帧 130 — `192.168.148.128 → 98.87.231.18`

**类型：TCP ACK（对服务器 FIN 的确认）**  
**含义：** 客户端确认收到了服务器的 FIN。至此四次挥手完成，双方均进入连接关闭/终止状态。**作用：** 四次挥手的最后一步，彻底关闭连接的双向通道。

---

### 额外说明（把抓包里看到的字段串起来理解）

- **三次握手（帧 107/111/112）**：建立可靠的 TCP 连接。之后客户端在该连接上发送 HTTP 请求（帧 113）。
- **ACK（帧 114 / 120 / 125 / 130）**：都是 TCP 的确认包，表明对方已收到了前序的数据。注意：很多 ACK 长度为 0（Len=0），它们只是确认，不承载数据。
- **HTTP 响应（帧 119）**：应用层返回 503，说明服务端拒绝/无法处理请求，这是 HTTP 层面的状态，不是网络层/传输层错误。
- **连接关闭（帧 123/125/129/130）**：标准的 TCP 四次挥手（FIN/ACK 交替），表明连接被有序关闭。
- **PSH（若出现）**：表示发送方希望接收方尽快把数据上交给应用层（不在抓包里单独解释，但帧 129 有 `PSH`，说明服务器在发送 FIN 的同时还推送了最后的数据）。
- **窗口（Win）与序号（Seq/Ack）**：用来表示流控与已确认字节位置，读包时能帮助判断是否有丢包/重传或数据分片。

---

### 小结

抓包显示了一个完整的会话生命周期：**TCP 三次握手 → 客户端发 GET（帧113）→ 服务器返回 HTTP 503（帧119）→ 双方相互 ACK → 双向 FIN 四次挥手关闭连接（帧123/125/129/130）**。每个 ACK/FIN/SYN 的存在都是 TCP 保证可靠传输与有序关闭的机制在起作用。

上面一共有11个帧，前三个帧用于tcp连接的建立，最后四个帧用于tcp连接的关闭。中间http一次请求一次响应，服务器在收到请求会使用一帧回复确认，客户端在收到服务器的响应会回复一个帧用于确认。

---

## 分析

![](1762595269193-dbb3f5a8-9fb7-4350-9939-83ae9db373fa.png)

上面是在命令行两次调用`**curl -v 192.168.148.1:8080/**` 两次的地址 不一样所以响应不一样， 因为是分两次调用所以上面是两次tcp连接，没有得到tcp连接的服用。

与上面的单个tcp连接的不同的是，在350帧351帧，这两帧是服务器响应给客户端的响应，

```
[TCP segment of a reassembled PDU]
[TCP PDU reassembled in frame 353]
```

TCP 是 **面向字节流** 的协议，大数据会被拆分成多个 TCP 段（segment）发送。  
Wireshark 在分析上层协议（例如 HTTP、TLS、MySQL 等）时，会自动尝试将这些分片重新拼回完整的上层 PDU（Protocol Data Unit，协议数据单元）。

于是你会看到：

- **“TCP segment of a reassembled PDU”**  
    表示当前这一帧只是某个上层消息的一部分；
- **“TCP PDU reassembled in frame 353”**  
    表示多个 TCP 段被重组后，完整的上层协议数据在第 353 帧中被拼接完成。

### 举个例子

假设一个 HTTP 请求体有 10KB，但单个 TCP 段的 MSS（最大分段大小）为 1460 字节，  
那么这个 HTTP 请求就会被分成大约 7~8 个 TCP 包。

Wireshark 会显示：

```
Frame 350: TCP segment of a reassembled PDU
Frame 351: TCP segment of a reassembled PDU
Frame 352: TCP segment of a reassembled PDU
Frame 353: HTTP POST /upload  (TCP PDU reassembled in frame 353)
```

也就是说：

- 350～352 是这个 HTTP 请求体的一部分；
- 到第 353 帧时，Wireshark 已经成功把之前几个段拼起来，得到完整的 HTTP 报文。

### 第 353 帧不是网络上实际存在的单个 TCP 报文

第 353 帧是 Wireshark 给你看的“重组视图”，真实网络中并不存在单独的 TCP 报文。

想象你发了一封信（上层消息）：

- 信纸太大，邮局拆成 3 个信封发送，每个信封里只有一部分内容。
- 你在 Wireshark 里看到：

- 信封 1 → Frame 350
- 信封 2 → Frame 351
- 信封 3 → Frame 352

- Wireshark帮你把三个信封内容拼起来 → Frame 353（完整信件），这个信件是**虚拟的，不是真正的帧**。

### 为什么会tcp分包

```
网络传输情况（TCP 分段）：

Frame 250 (TCP segment)
┌──────────────────────────────────────────────┐
│ HTTP Response Header                          │
│ HTTP/1.1 404 ...                              │
│ Transfer-Encoding: chunked                    │
│ ...                                           │
│                                              │
│ 59\r\n                                        │ <-- chunk 长度
│ {"timestamp":"2025-11-08T09:43:02.049+00:00" │ <-- chunk 数据
│ ,"status":404,"error":"Not Found","path":"/"}│
└──────────────────────────────────────────────┘

Frame 251 (TCP segment)
┌─────────────┐
│ 0\r\n\r\n    │ <-- chunked encoding 结束标志
└─────────────┘

Wireshark 重组（完整 HTTP PDU）：
┌──────────────────────────────────────────────┐
│ HTTP Response Header                          │
│ HTTP/1.1 404 ...                              │
│ Transfer-Encoding: chunked                    │
│ ...                                           │
│                                              │
│ 59\r\n                                        │
│ {"timestamp":"2025-11-08T09:43:02.049+00:00" │
│ ,"status":404,"error":"Not Found","path":"/"}│
│ 0\r\n\r\n                                     │ <-- 拼接完成
└──────────────────────────────────────────────┘
```

### 🔑 核心点

1. **TCP 分段**：

- 网络上每个 TCP segment 的大小取决于 MSS（最大报文段长度）。
- 就算只剩 5 个字节，也会单独发一个 segment。

2. **HTTP chunked encoding**：

- 每个 chunk：`<chunk-size>\r\n<chunk-data>\r\n`
- 最后一块：`0\r\n\r\n` 表示结束。

3. **Wireshark 重组**：

- 把多个 TCP segment payload 拼接起来，形成完整 HTTP PDU。
- 所以第 250 帧看起来完整，但最后 251 帧的数据才是真正的 chunked 结束标记。

这个问题非常关键，也是理解 TCP 和上层协议之间关系的核心。我们一步步来分析：

---

## 1️⃣ TCP 的本质：面向字节流

TCP 是 **面向字节流的传输层协议**，有几个关键特点：

1. **可靠传输**：保证数据不丢失、按序到达。
2. **面向字节流**：应用层发送的“消息边界” TCP 并不感知。

- 比如你一次 send 1000 字节，TCP 可以分成 2 个 segment 发送：700 + 300 字节。
- 接收方 TCP 会把字节按序重组，但不会告诉应用层“700 是一条消息，300 是另一条消息”。

3. **顺序编号**：每个字节都有一个序号（sequence number），接收方根据序号拼接。

---

## 2️⃣ TCP 是如何知道要“重组”的

TCP 重组其实就是 **按序号拼接收到的字节**，具体流程：

1. 每个 TCP segment 都有：

- 序号（Sequence Number）：当前 segment 第一个字节的序号。
- 确认号（Ack Number）：告诉发送方已收到的数据序号。

2. 接收方维护一个 **接收缓冲区**：

- 收到 segment 后，根据序号放入缓冲区。
- 如果中间有缺失 segment，TCP 会等待重传。

3. 接收方把缓冲区里的字节 **按序交给应用层**（一次或多次 read）。

所以 TCP 并不“知道”上层消息边界，它只负责把字节按序拼好。

---

## 3️⃣ 上层协议（HTTP）如何重组

- TCP 只保证字节流按序到达，不保证“一个 send 就是一个消息”。
- **HTTP 或其他应用层协议**（如 MySQL、SMTP）自己定义消息边界：

1. **Content-Length**：读固定字节数。
2. **Chunked encoding**：读 chunk-size + chunk-data，直到 `0\r\n\r\n`。
3. **定界符**（如 `\r\n\r\n` 分割头部和 body）。

Wireshark 做的重组就是模拟应用层逻辑，把 TCP payload 拼起来形成完整的 PDU（HTTP 报文、MySQL 数据包等）。

---

## 4️⃣ 举个例子

你抓的 HTTP chunked body：

```
TCP segment 250: HTTP header + chunk 数据（部分）
TCP segment 251: chunk 结束标志 0\r\n\r\n
```

TCP 接收方流程：

1. 收到 segment 250，把字节放缓冲区。
2. 收到 segment 251，把字节追加到缓冲区。
3. TCP 将缓冲区的字节交给上层协议（HTTP）。
4. HTTP 根据 chunked encoding 规则知道完整消息结束。

Wireshark 就是**模拟 HTTP 解析**，把 segment 250+251 拼接显示成完整 HTTP PDU。

---

### 🔑 核心结论

1. TCP 重组只依赖 **序号 + 接收缓冲区**。
2. TCP 并不理解消息边界，上层协议决定“消息完整”的定义。
3. Wireshark 的 “reassembled PDU” 只是上层协议逻辑解析后的展示结果。

---

如果你愿意，我可以画一张 **TCP segment → 缓冲区 → 上层协议重组 → Wireshark PDU** 流程图，帮你直观理解整个过程。

你希望我画吗？

### 3️⃣ 核心理解

- TCP **只对数据段进行重组**，把连续字节拼好交给上层。
- **纯控制段**（没有数据 payload）不会交给应用层。
- 上层协议自己判断消息边界（Content-Length / chunked / 定界符）。

所以可以简单记作：

**“只要是有数据的 TCP segment，就参与拼装；纯确认或控制段不交给上层。”**

完全正确！这正是 TCP 的核心概念。我们来把它梳理清楚：

---

### 1️⃣ **TCP 是字节流**

- **TCP 本质上是** **面向字节流（stream-oriented）****，而不是面向消息（message-oriented）。**
- **发送方** `**send()**` **一次，接收方** `**recv()**` **不保证一次就能收到完全对应的那一条消息。**
- **TCP 只保证：**

1. **字节不丢失**
2. **按序到达**
3. **可靠重传**

**因此，网络上的每个 TCP segment 都只是这个** **字节流的一部分****，它们组合起来就是连续的数据流。**

---

### 2️⃣ **粘包与拆包的原因**

**粘包****：多条应用消息被 TCP 当作一个连续流发送，接收方一次** `**recv()**` **可能接到多条消息连在一起。****拆包****：一条应用消息过大，跨多个 TCP segment 发送，接收方一次** `**recv()**` **可能只收到一部分。**

**原因****：TCP 不知道上层消息边界，只管字节流。**

---

### 3️⃣ **解决方法：应用层协议分界**

**应用层必须自己定义消息边界，常见方式：**

1. **固定长度**

- **每条消息长度固定，例如 1024 字节，接收方按长度切分。**

2. **消息头 + 长度字段**

- **例如：**`**[length:4][body:length]**`**，接收方先读长度，再读对应字节。**

3. **特殊分隔符**

- **例如 HTTP 用** `**\r\n\r\n**` **分隔 header 和 body。**

4. **Chunked / 自定义协议**

- **HTTP chunked 或流式协议，每条 chunk 有长度字段或结束标记。**

---

### 4️⃣ **总结概念**

- **TCP = 字节流** **→ segment 只是流的一部分，可能粘包/拆包。**
- **应用层协议 = 消息流** **→ 必须设计边界，让接收方能正确解析消息。**
- **Wireshark** **的 TCP 重组就是模拟上层协议解析，把这些散落的 segment 拼成完整 PDU。**

---

### tcp复用

![](1762600304418-f2c16759-b6f7-4bf7-850d-34031b080ba6.png)

通过curl发送两个http请求

```
curl -v 192.168.148.1:8080/ --keepalive-time 60  --next  192.168.148.1:8080/hello
```

使用一个命令去同时发送两个http请求可以确保tcp连接的复用，同之前的分析需要注意的是，服务器在收到客户端的http请求所在的tcp确认帧中，携带了响应数据。

TCP 协议允许 **确认（ACK）与数据段复用**：

- TCP segment 可以同时：

1. **携带确认号**（ACK，告诉对方自己已收到哪些字节）
2. **携带数据**（payload，应用层数据）

- **不一定每个 ACK 都是空段**：

- 如果接收方有数据要发送，同时还要确认对方的数据，可以把 ACK 和数据合并在一个 segment 发出。
- 这就是所谓的 **“ACK piggybacking”**（搭便车 ACK）。

---

#### HTTP 响应 + TCP ACK 的情况

在 HTTP 响应场景下：

1. 客户端发送请求（比如 GET） → 发送方 TCP segment 带 SYN/ACK 或普通 ACK。
2. 服务器准备响应数据：

- TCP 先确认客户端请求的到达（ACK）
- 同时把 HTTP 响应数据放到 TCP payload 中发送

所以你看到的 **服务器 TCP segment** 可能同时有：

```
SEQ = 响应数据的起始序号
ACK = 客户端请求的最后字节序号 + 1
Payload = HTTP 响应数据
```

#### 测试一下接口在阻塞一段时间后返回响应

![](1762600902392-f4ddfcdd-61cd-427a-9b7d-7540a6dbaa17.png)

可以清楚的看到这次响应和ack分成两个帧了

#### 阻塞对 TCP segment 的影响

当你给接口加了短时间阻塞（比如 sleep/延迟处理请求）：

- **服务器应用层没有立即生成数据** → TCP 发送缓冲区暂时没有 payload
- TCP stack 仍然需要 **确认客户端之前发送的数据** → 发送 **纯 ACK segment**
- 因此你看到的 segment **只有 ACK，没有 HTTP 数据**

这就是 TCP ACK **分开发送**的情况。

---

#### TCP 的发送策略

TCP 栈在发送数据时，会根据几个因素决定是否把数据和 ACK 合并：

1. **Nagle 算法**：

- 如果有小量数据没发送，TCP 会等到：

- 累积到 MSS
- 或者收到 ACK
- 才发送数据

- 如果你的延迟阻塞了数据生成，Nagle 会让 TCP 等待一会儿 → 先发送纯 ACK

2. **延迟 ACK (Delayed ACK)**：

- TCP 栈可能延迟 100~200ms 才发送 ACK
- 如果此时应用层还没数据，发送的就是空 ACK

3. **PSH 标志**：

- PSH 是由 TCP 栈根据应用层 push 数据策略设置的
- 如果应用层没有数据，ACK 自然不会带 PSH

---

- **不阻塞时**：

- 应用层立即生成 HTTP 响应
- TCP segment 携带数据 + ACK → `[PSH, ACK]`

- **短时间阻塞时**：

- 应用层还没生成数据
- TCP 必须确认客户端请求 → 发送纯 ACK → `[ACK]`
- 后续生成数据后，再发送 `[PSH, ACK]` 携带 HTTP payload