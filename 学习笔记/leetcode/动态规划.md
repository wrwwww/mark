## [115.不同的子序列](https://leetcode.cn/problems/distinct-subsequences/description/)

### 1. 问题描述

给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。

![](lake%20import/leetcode/Attachments/1705289520175-9f2556be-0c79-40a7-97e1-3942cc478a29.png)

### 2. 分析

1. s的长度应该大于等于t,这样t才有可能是s的子序列(s.length>=t.length)

## [279.完全平方数](https://leetcode.cn/problems/perfect-squares/description/)

### 1. 问题描述

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
### 2. 分析

用最少的数拼这个整数n

我们可以维护一个一维数组db,db[i]为整数i所需的最少的次数,在寻找n的最少次数的时候,我们遍历所有的完全平方数j(大于等于1,平方小于等于n的数),使用n-j*j 得到剩余部分的数,然后接下来的部分就是找到这个数的最少组成次数,而这个数一定是小于n的,是在n获取n之前已经获得的

### 3. 代码

```
    public int numSquares(int n) {
    	// db数组,db[i],记录i这个数用的最少完全平方数的个数
        int[] nums = new int[n + 1];

    	// 从1开始构建这个db数组
        for (int i = 1; i < nums.length; i++) {
            // 使用minNUm来记录最少次数
            int minNum = Integer.MAX_VALUE;
            // 便利符合条件的完全平方数
            for (int j = 1; j * j <= i; j++) {
                // 这个是找最少次数,用i-j*j得到的是最少次数
                minNum = Integer.min(minNum, nums[i - j * j]);
            }
            nums[i] = minNum + 1;	
        }
        return nums[n];
    }
```

## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

### 1. 问题描述

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

![](lake%20import/leetcode/Attachments/1705310793927-8ac9cf6c-2daf-4165-8c90-41129a1dc55f.png)

### 2. 分析

类似279题一样,我们构建一个db数组,记录0-amount之间的每个金额的最少金币次数,

这应该是一个完全背包问题,因为题目提供我们选择的额度,所以会出现不能填满的情况,所有我们最后需要做个额外判断

### 3. 代码

```
 public int coinChange(int[] coins, int amount) {
        int[] db = new int[amount + 1];
        Arrays.fill(db, amount + 1);
        db[0] = 0;
        for (int i = 1; i < db.length; i++) {
            for (int coin : coins) {
                if (coin <= i)
                    db[i] = Math.min(db[i - coin] + 1, db[i]);
            }
        }

        return db[amount] > amount ? -1 : db[amount];
    }
```

```
// 就是把所有可能性都添加一次,然后在计算的时候利用一个一维数组来减少计算,达到剪枝
public int coinChange2(int[] coins, int amount) {
        if (amount == 0) return 0;
        return coinChange(coins, amount, new int[amount]);
    }

    public int coinChange(int[] coins, int rem, int[] count) {

        if (rem < 0) {
            return -1;
        }
        if (rem == 0) {
            return 0;
        }
        if (count[rem - 1] != 0) {
            return count[rem - 1];
        }
        int min = Integer.MAX_VALUE;
        for (int coin : coins) {
            int res = coinChange(coins, rem - coin, count);
            if (res >= 0 && res < min) {
                min = res + 1;
            }
        }
        count[rem - 1] = min == Integer.MAX_VALUE ? -1 : min;
        return count[rem - 1];
    }
```

## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

### 1. 问题描述

### 2. 分析

首先长度小于2的一定不能分割出等和子集

sum为奇数的也不可以

然后就可以把这个问题转为一个0/1背包问题,从指定列表中选取任意元素一次去凑出sum/2

然后建立

### 3. 代码

```
// 方法一 二维db
    public boolean canPartition(int[] nums) {

        // 长度小于2的肯定不可以
        if (nums.length < 2) return false;
        int sum = Arrays.stream(nums).sum();
        // 应该能被2整除
        if (sum % 2 != 0) return false;
        int target = sum / 2;
        // 定义状态数组
        int[][] db = new int[nums.length][target + 1];
        // 处理第一个
        for (int i = 0; i <= target; i++) {
            db[0][i] = i >= nums[0] ? nums[0] : 0;
        }

        // 处理其他行
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= target; j++) {
                // 不选的情况
                int a = db[i - 1][j];
                // 选择
                int b = nums[i] <= j ? db[i - 1][j - nums[i]] + nums[i] : 0;
                db[i][j] = Math.max(a, b);

            }
        }

        return db[nums.length - 1][target] == target;
    }

    // 滚动数组
    public boolean canPartition2(int[] nums) {

        // 长度小于2的肯定不可以
        if (nums.length < 2) return false;
        int sum = Arrays.stream(nums).sum();
        // 应该能被2整除
        if (sum % 2 != 0) return false;
        int target = sum / 2;
        // 定义状态数组
        int[][] db = new int[2][target + 1];
        // 处理第一个
        for (int i = 0; i <= target; i++) {
            db[0][i] = i >= nums[0] ? nums[0] : 0;
        }

        // 处理其他行
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= target; j++) {
                // 不选的情况
                int a = db[(i - 1) & 1][j];
                // 选择
                int b = nums[i] <= j ? db[(i - 1) & 1][j - nums[i]] + nums[i] : 0;
                db[i & 1][j] = Math.max(a, b);

            }
        }

        return db[1][target] == target;
    }

    // 一维数组
    public boolean canPartition3(int[] nums) {

        // 长度小于2的肯定不可以
        if (nums.length < 2) return false;
        int sum = Arrays.stream(nums).sum();
        // 应该能被2整除
        if (sum % 2 != 0) return false;
        int target = sum / 2;
        // 定义状态数组
        int[] db = new int[target + 1];
        // 处理第一个
        for (int i = 0; i <= target; i++) {
            db[i] = i >= nums[0] ? nums[0] : 0;
        }

        // 处理其他行
        for (int i = 1; i < nums.length; i++) {
            // 因为每一行使用的都是前一行的内容,而且使用的是当前列,以及当前列之前的数据,所以可以优化为一维数组
            for (int j = target; j >= 0; j--) {
                // 不选的情况
                int a = db[j];
                // 选择
                int b = nums[i] <= j ? db[j - nums[i]] + nums[i] : 0;
                db[j] = Math.max(a, b);

            }
        }

        return db[target] == target;
    }
```

## [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

### 问题描述

### 分析

### 代码

## [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

### 问题描述

### 分析

### 代码

## [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

### 问题描述

### 分析

### 代码